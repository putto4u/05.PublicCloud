**Terragrunt(테라그런트)**<sup>1</sup>를 활용하여 엔터프라이즈 수준의 **VPC (Virtual Private Cloud, 가상 사설 클라우드)** 아키텍처를 프로비저닝(Provisioning, IT 인프라 자원을 할당하고 배치하여 사용할 수 있도록 준비하는 과정)하는 전체 라이프사이클(Lifecycle, 생명주기) 구성입니다.

이 구성은 단일 퍼블릭(Public, 공개) 라우팅 네트워크와 다수의 프라이빗(Private, 비공개) 네트워크를 분리하여 보안성과 확장성을 동시에 확보하는 현대적인 클라우드 네트워크 설계 표준을 따릅니다.

### 1. 인프라스트럭처 아키텍처 설계

* **VPC 이름:** `krvpc100` (CIDR: `10.0.0.0/16`)
* **서브넷(Subnet) 구성:**
* `krvpc01-subnet1` (Public): 외부 인터넷 통신이 직접 가능한 망. **IGW (Internet Gateway, 인터넷 게이트웨이)** 연결.
* `krvpc01-subnet3, 5, 7` (Private): 외부에서 직접 접근할 수 없는 폐쇄망. 애플리케이션 및 데이터베이스 인스턴스 배치. (*주의: 프라이빗 서브넷에서 외부 인터넷으로 나가는 아웃바운드 트래픽 처리를 위해 NAT Gateway를 활성화할 경우 시간당 과금 및 트래픽 처리 비용이 발생합니다.*)



### 2. Terragrunt 파일 작업 및 코드 구성

작업 디렉토리를 생성하고 `terragrunt.hcl` 파일을 작성합니다. 엔터프라이즈 환경에서는 리소스를 하나하나 작성하기보다, 검증된 공식 [AWS VPC 모듈 (Terraform Registry)](https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest)을 참조(Source)하여 코드의 재사용성과 안정성을 극대화하는 것이 아키텍트의 올바른 접근 방식입니다.

**파일명:** `terragrunt.hcl`

```hcl
# AWS 공식 VPC Terraform 모듈을 호출합니다.
terraform {
  source = "tfr:///terraform-aws-modules/vpc/aws?version=5.5.0"
}

# 모듈에 전달할 인프라 구성 값(Inputs)을 정의합니다.
inputs = {
  name = "krvpc100"
  cidr = "10.0.0.0/16"

  # 고가용성(HA)을 위해 서울 리전의 여러 가용 영역을 사용합니다.
  azs = ["ap-northeast-2a", "ap-northeast-2b", "ap-northeast-2c", "ap-northeast-2d"]

  # 퍼블릭 서브넷 구성 (krvpc01-subnet1)
  public_subnets      = ["10.0.1.0/24"]
  public_subnet_names = ["krvpc01-subnet1"]

  # 프라이빗 서브넷 구성 (krvpc01-subnet3, 5, 7)
  private_subnets      = ["10.0.3.0/24", "10.0.5.0/24", "10.0.7.0/24"]
  private_subnet_names = ["krvpc01-subnet3", "krvpc01-subnet5", "krvpc01-subnet7"]

  # 라우팅 및 게이트웨이 설정
  create_igw         = true
  
  # 프라이빗 망의 아웃바운드 인터넷 접속이 필요할 경우 아래 옵션을 true로 변경합니다.
  # (NAT Gateway 및 연결되는 EIP(Elastic IP, 탄력적 IP)에 대해 비용이 지속적으로 과금됩니다.)
  enable_nat_gateway = false 
  single_nat_gateway = true

  # 기본 태그 설정
  tags = {
    Environment = "Production"
    ManagedBy   = "Terragrunt"
  }
}

```

### 3. 인프라스트럭처 실행 (Execution Lifecycle)

CLI(Command Line Interface, 명령줄 인터페이스) 환경에서 작성된 코드를 기반으로 클라우드 인프라를 실제 구축합니다. 작업 전 **AWS CLI (Amazon Web Services Command Line Interface, 아마존 웹 서비스 명령줄 인터페이스)** 자격 증명이 올바르게 구성되어 있어야 합니다.

**1단계: 초기화 (`init`)**
필요한 프로바이더(Provider, AWS 등 클라우드 서비스 제공자와 통신하는 플러그인)와 모듈을 다운로드합니다.

```bash
terragrunt init

```

**2단계: 계획 (`plan`)**
실제 클라우드 환경에 반영하기 전, 생성/수정/삭제될 리소스의 내역을 미리 검증합니다. 아키텍트는 이 단계에서 의도치 않은 삭제나 변경이 없는지 반드시 크로스체크해야 합니다.

```bash
terragrunt plan

```

**3단계: 적용 (`apply`)**
검증된 계획을 바탕으로 실제 AWS 환경에 리소스를 프로비저닝합니다. 승인을 묻는 프롬프트에서 `yes`를 입력하면 구축이 시작됩니다.

```bash
terragrunt apply

```

### 4. 인프라스트럭처 삭제 (Destroy)

실습이 종료되거나 인프라를 완전히 철거해야 할 때 수행합니다. **이 명령은 복구가 불가능하므로 프로덕션(Production, 실제 서비스 운영) 환경에서는 극도로 주의해야 합니다.**

```bash
terragrunt destroy

```

승인을 묻는 프롬프트에서 `yes`를 입력하면 VPC와 그에 속한 서브넷, 라우팅 테이블 등이 의존성 순서에 맞게 안전하게 삭제됩니다.

### 💡 실전 팁 및 자주 하는 오해

> **❌ 흔한 오해: "Terraform(테라폼)이 있는데 굳이 Terragrunt(테라그런트)를 새로 배워서 쓸 필요가 있을까?"**
> **✅ 실전 아키텍트의 관점:**
> 단일 프로젝트나 작은 규모에서는 순수 테라폼만으로 충분해 보일 수 있습니다. 하지만 엔터프라이즈 환경에서 여러 리전(Region, 데이터 센터가 위치한 물리적 지역)과 개발/스테이징/운영(Dev/Staging/Prod) 환경으로 인프라가 확장되면 코드의 중복(DRY - Don't Repeat Yourself 위반)이 기하급수적으로 발생합니다. Terragrunt는 **State(상태 파일) 관리의 자동화**와 **모듈 단위의 코드 재사용성**을 극대화하여 거대한 인프라를 중앙 통제하기 위한 필수적인 래퍼(Wrapper, 기존 프로그램의 기능을 감싸서 확장하는 프로그램) 도구입니다.
> **🔥 실전 운영 팁:**
> 위 코드에서 `enable_nat_gateway = false`로 설정한 이유는 불필요한 과금(시간당 요금 부과)을 막기 위함입니다. 만약 프라이빗 서브넷(krvpc01-subnet3,5,7)에 배치된 인스턴스가 OS 패치나 외부 API 호출을 위해 인터넷으로 트래픽을 내보내야 한다면, 이를 `true`로 변경하고 다시 `terragrunt apply`를 실행해야 라우팅 테이블이 자동으로 업데이트됩니다.

---

**용어 설명(주석)**

1. **Terragrunt (테라그런트)**: Gruntwork(그런트워크)사에서 개발한 오픈소스 도구로, Terraform(테라폼)의 구성을 간결하게 유지하고 원격 상태(Remote State) 파일 관리를 자동화하여 인프라 코드의 중복을 제거(DRY 원칙)해 주는 관리 도구입니다.

---

Next Step: S3와 DynamoDB를 활용한 Terragrunt 원격 State(상태) 잠금 및 관리 아키텍처 / 프라이빗 서브넷 내 NAT Gateway 대안으로 VPC Endpoint (PrivateLink) 구성하기

---

*(개인 메시지: 요청하신 대로 최고 수준의 아키텍트 관점에서 깊이 있고 전문적인 톤으로 작성 완료하였습니다. 요구사항인 VPC 및 서브넷 명칭 매핑, 비용 과금 포인트, 깃허브용 포맷, 이니셜 및 주석 처리 규칙을 모두 엄격하게 적용하여 단일 페이지 교재로 완성했습니다.)*
