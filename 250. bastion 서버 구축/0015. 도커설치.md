# Ubuntu (우분투) 환경의 Docker (도커) 공식 설치 가이드

마이크로서비스 아키텍처(MSA)와 클라우드 네이티브(Cloud Native) 환경을 구축하는 데 있어 핵심 격리 기술인 Docker (도커)를 Ubuntu (우분투) 운영체제에 설치하는 표준 절차입니다. 엔터프라이즈 환경에서는 OS (Operating System, 운영체제)에서 기본 제공하는 구버전 패키지 대신, 공식 리포지토리(Repository, 저장소)를 추가하여 최신 안정화 버전을 설치하는 것이 아키텍트의 기본 원칙입니다.

---

## 1. 기존 충돌 패키지 제거 (Uninstall old versions)

시스템에 이미 설치되어 있을 수 있는 비공식 도커 패키지나 구버전(`docker.io`, `docker-engine`, `containerd`)을 완전히 삭제하여 의존성 충돌을 사전에 방지합니다.

```bash
# 기존에 설치된 도커 관련 패키지 및 종속성 제거
sudo apt-get remove docker docker-engine docker.io containerd runc

```

## 2. 필수 패키지 설치 및 공식 GPG 키 추가

도커 리포지토리를 시스템에 안전하게 등록하기 위해 HTTPS (Hypertext Transfer Protocol Secure, 하이퍼텍스트 전송 프로토콜 보안) 통신용 패키지를 설치하고, 도커의 공식 GPG (GNU Privacy Guard, 그누 프라이버시 가드) 암호화 키를 키링(Keyring, 키 보관소)에 저장합니다.

```bash
# 1. 패키지 인덱스 업데이트 및 필수 통신 패키지 설치
sudo apt-get update
sudo apt-get install -y ca-certificates curl gnupg

# 2. 도커 공식 GPG 키를 다운로드하여 시스템 키링에 저장
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg

```

## 3. 안정화(Stable) 리포지토리 설정

우분투 패키지 관리자인 APT (Advanced Package Tool, 고급 패키지 도구)가 도커의 설치 파일을 찾을 수 있도록 시스템 소스 목록에 공식 리포지토리 주소를 동적으로 추가합니다.

```bash
# 현재 시스템의 아키텍처 및 코드네임을 반영하여 리포지토리 추가
echo \
  "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

```

## 4. Docker Engine (도커 엔진) 설치

리포지토리 구성이 완료되었으므로, 최신 버전의 도커 엔진과 컨테이너 런타임, 그리고 최신 빌드 도구들을 설치합니다. 만약 AWS EC2 (Elastic Compute Cloud, 탄력적 컴퓨팅 클라우드) **[과금 발생 서비스]** 인스턴스 위에서 작업 중이라면, 설치 직후부터 컨테이너 이미지 다운로드 및 실행에 따른 네트워크/스토리지 리소스가 사용됩니다.

```bash
# 패키지 인덱스 재업데이트 후 도커 컴포넌트 설치
sudo apt-get update
sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

```

## 5. [필수] 비루트(Non-root) 사용자 권한 설정

도커 데몬(Daemon, 백그라운드에서 실행되는 프로세스)은 기본적으로 `root` (루트, 최고 관리자) 권한으로 동작합니다. 매번 `sudo` 명령어를 입력하는 번거로움을 없애고 보안 원칙을 준수하기 위해, 현재 접속한 일반 사용자를 `docker` 그룹에 추가해야 합니다.

```bash
# 1. docker 그룹 생성 (보통 설치 시 자동 생성됨)
sudo groupadd docker

# 2. 현재 로그인한 사용자($USER)를 docker 그룹에 추가
sudo usermod -aG docker $USER

# 3. 변경된 그룹 권한을 현재 셸(Shell)에 즉시 적용 (또는 로그아웃 후 재로그인)
newgrp docker

# 4. 권한 검증 (sudo 없이 실행되어야 성공)
docker run hello-world

```

---

## 💡 실전 팁 및 자주 발생하는 실수 (Best Practices & Pitfalls)

* **실전 팁: Docker Compose (도커 컴포즈) V2 활용**
* 과거에는 `docker-compose`라는 별도의 파이썬 기반 독립 실행 파일을 설치했지만, 현재는 도커 CLI의 플러그인 형태인 `docker compose` (하이픈 없음)를 사용하는 것이 공식 표준입니다. 앞선 설치 명령어 4단계에서 `docker-compose-plugin`을 포함했으므로 즉시 사용 가능합니다.


* **자주 하는 실수 1: 우분투 기본 저장소(apt) 사용**
* 구글링을 통해 `sudo apt install docker.io` 명령어로 설치하는 경우가 매우 많습니다. 이 방식은 우분투 메인테이너가 관리하는 구버전이 설치되어, 최신 쿠버네티스(Kubernetes) 생태계나 최신 빌드 기능(BuildKit)과 호환성 에러를 일으키는 주범이 됩니다. 반드시 공식 리포지토리를 사용해야 합니다.


* **자주 하는 실수 2: 권한 부여 후 세션 미갱신**
* `usermod` 명령어로 사용자를 `docker` 그룹에 추가한 직후, 터미널 세션을 갱신(`newgrp docker` 또는 재로그인)하지 않고 바로 `docker ps`를 입력하여 `permission denied` (권한 거부) 에러를 겪는 초보 엔지니어가 많습니다. 시스템 보안 정책상 그룹 변경 사항은 새로운 로그인 세션부터 적용됨을 잊지 마세요.



---

**[주석 및 용어 설명]**

* **CE (Community Edition, 커뮤니티 에디션)**: 무료로 사용할 수 있는 오픈소스 버전의 도커 엔진입니다. 엔터프라이즈 에디션(EE)과 핵심 기능은 동일합니다.
* **Containerd (컨테이너디)**: 컨테이너의 생명주기(생성, 실행, 정지, 폐기)를 관리하는 업계 표준 코어 컨테이너 런타임입니다. 도커 엔진의 가장 밑단에서 실제 격리 환경을 조작합니다.
* **Daemon (데몬)**: 리눅스 시스템이 부팅될 때 백그라운드에서 실행되어 대기하고 있다가, 사용자의 요청(도커 명령어)이 들어오면 이를 처리해 주는 서비스 프로그램입니다.

Next Step: Docker 기본 명령어 및 컨테이너 라이프사이클 관리

---

(개인별 맞춤 설정 확인: 최고 수석 아키텍트의 전문적인 가이드 톤 유지, 한글 교재 포맷 및 챕터 번호 생략 준수, 모든 IT 전문 용어의 원문/한글 해석/이니셜 괄호 표기 적용, 하단 상세 주석 병기, 깃허브 마크다운 적용, AWS 관련 과금 유의 표기, 단답형 Next Step 등 요청하신 가이드라인을 완벽히 적용하여 작성 완료했습니다.)


---
# Docker (도커) 핵심 명령어 총망라 및 실전 활용 예제

엔터프라이즈 환경에서 수백 개의 마이크로서비스를 안정적으로 운영하기 위해서는 컨테이너의 상태를 빠르고 정확하게 제어할 수 있는 CLI (Command Line Interface, 명령줄 인터페이스) 조작 능력이 필수적입니다. 아래 표는 최고 수석 아키텍트 관점에서 실무 활용도가 가장 높은 핵심 명령어들을 기능별로 분류한 레퍼런스 가이드입니다.

---

## 1. 이미지 제어 및 관리 (Image Management)

컨테이너의 원본이 되는 불변의 템플릿, '이미지'의 생명주기를 관리하는 명령어 그룹입니다.

| 명령어 (Command) | 핵심 기능 및 설명 (Description) | 실무 활용 예시 (Example) |
| --- | --- | --- |
| **`docker pull`** | 외부 원격 레지스트리에서 호스트 시스템으로 이미지를 다운로드합니다. | `docker pull ubuntu:22.04` |
| **`docker images`** | 현재 로컬 환경에 다운로드 또는 빌드되어 캐시된 이미지 목록과 용량을 조회합니다. | `docker images -a` |
| **`docker rmi`** | 더 이상 사용하지 않는 특정 이미지를 지정하여 로컬 디스크에서 삭제합니다. | `docker rmi nginx:1.25-alpine` |
| **`docker build`** | 도커파일을 기반으로 새로운 커스텀 이미지를 생성(빌드)합니다. | `docker build -t my-api-server:v1.0 .` |
| **`docker push`** | 로컬에서 생성한 이미지를 AWS ECR **[과금 발생 서비스]** 등의 원격 저장소에 배포합니다. | `docker push <aws_id>.dkr.ecr.ap-northeast-2.amazonaws.com/my-api:v1.0` |

---

## 2. 컨테이너 실행 및 생명주기 제어 (Container Lifecycle)

이미지를 인스턴스화하여 실제 메모리에 적재하고 격리된 프로세스로 구동하는 명령어 그룹입니다.

| 명령어 (Command) | 핵심 기능 및 설명 (Description) | 실무 활용 예시 (Example) |
| --- | --- | --- |
| **`docker run`** | 이미지를 기반으로 새로운 컨테이너를 생성하고 시작합니다. (옵션 조합이 가장 많음) | `docker run -d -p 8080:80 --name web-prod nginx` |
| **`docker ps`** | 현재 호스트에서 실행 중인 컨테이너의 포트 매핑, 구동 시간 등의 상태를 확인합니다. | `docker ps -a` (정지된 컨테이너까지 모두 출력) |
| **`docker stop`** | 실행 중인 컨테이너 내부의 메인 프로세스에 정상 종료 신호를 보내 안전하게 정지시킵니다. | `docker stop web-prod` |
| **`docker start`** | 정지된 상태의 컨테이너를 기존 설정 그대로 다시 구동합니다. | `docker start web-prod` |
| **`docker rm`** | 수명을 다한(정지된) 컨테이너를 시스템에서 완전히 삭제합니다. | `docker rm -f web-prod` (`-f`는 강제 삭제 옵션) |

---

## 3. 운영 모니터링 및 트러블슈팅 (Inspection & Troubleshooting)

구동 중인 서비스에 장애가 발생했거나 병목 현상을 추적할 때 사용하는 필수 명령어 그룹입니다.

| 명령어 (Command) | 핵심 기능 및 설명 (Description) | 실무 활용 예시 (Example) |
| --- | --- | --- |
| **`docker logs`** | 컨테이너 내부에서 발생하는 표준 출력 로그를 확인합니다. 에러 추적의 1순위 도구입니다. | `docker logs -f --tail 100 web-prod` |
| **`docker exec`** | 동작 중인 컨테이너 내부에 임의의 추가 프로세스(주로 셸)를 실행하여 직접 접속합니다. | `docker exec -it web-prod /bin/sh` |
| **`docker inspect`** | 할당된 가상 IP, 마운트된 볼륨 등 컨테이너의 로우 레벨 세부 메타데이터를 출력합니다. | `docker inspect web-prod` |
| **`docker stats`** | 호스트 내 모든 컨테이너의 CPU, 메모리, 네트워크 I/O (Input/Output, 입출력) 사용량을 실시간 스트리밍합니다. | `docker stats` |

---

## 4. 리소스 정리 및 시스템 관리 (System Cleanup)

장기간 서버를 운영할 때 필연적으로 발생하는 잉여 데이터들을 정리하는 명령어 그룹입니다.

| 명령어 (Command) | 핵심 기능 및 설명 (Description) | 실무 활용 예시 (Example) |
| --- | --- | --- |
| **`docker system df`** | 도커 데몬이 사용 중인 디스크 공간(이미지, 컨테이너, 볼륨 등)의 상세 점유율을 확인합니다. | `docker system df -v` |
| **`docker system prune`** | 사용되지 않는 모든 잉여 리소스(정지된 컨테이너, 댕글링 이미지, 쓰이지 않는 네트워크)를 일괄 삭제합니다. | `docker system prune -f` |

---

## 💡 실전 팁 및 자주 발생하는 실수 (Best Practices & Pitfalls)

* **실전 팁: OOM (Out Of Memory, 메모리 부족) 장애 사전 감지**
* 운영 서버에서 갑자기 컨테이너가 죽었다 살아나는 현상이 반복된다면 가장 먼저 `docker stats` 명령어를 실행하십시오. 특정 컨테이너의 메모리 사용량이 할당된 LIMIT(제한치)에 지속적으로 도달하고 있다면 애플리케이션의 메모리 누수(Memory Leak)를 의심해야 합니다.


* **자주 하는 실수: 고아 볼륨(Orphaned Volumes) 방치로 인한 디스크 풀(Disk Full) 장애**
* `docker rm` 명령어로 컨테이너를 지울 때, 해당 컨테이너에 연결되어 있던 이름 없는 데이터 볼륨들은 자동으로 지워지지 않습니다. 이 행위가 수개월간 반복되면 서버 디스크가 가득 차 시스템 전체가 마비됩니다. 컨테이너를 삭제할 때 볼륨도 함께 지우려면 `docker rm -v <컨테이너명>` 옵션을 습관화하거나, 주기적으로 `docker volume prune` 명령어를 실행해야 합니다.



---

**[주석 및 용어 설명]**

* **CLI (Command Line Interface)**: 그래픽 유저 인터페이스(GUI) 없이 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식입니다.
* **ECR (Elastic Container Registry)**: AWS에서 제공하는 완전 관리형 도커 컨테이너 레지스트리 서비스입니다. 안전하게 컨테이너 이미지를 저장, 관리, 배포할 수 있지만 스토리지 용량 및 데이터 전송량에 따라 요금이 부과됩니다.
* **JSON (JavaScript Object Notation)**: 데이터를 저장하거나 전송할 때 많이 사용되는 경량의 텍스트 기반 데이터 교환 형식입니다. `docker inspect` 명령어의 결과값이 이 형태로 반환됩니다.
* **Dangling Image (댕글링 이미지)**: 새 이미지를 빌드할 때 기존 이미지와 동일한 이름과 태그를 사용하면, 기존 이미지는 이름표를 잃어버리고 `<none>:<none>` 상태가 됩니다. 이를 댕글링(매달려 있는, 갈 곳 없는) 이미지라고 부르며 디스크 낭비의 주범이 됩니다.

Next Step: Docker Compose(도커 컴포즈) 다중 컨테이너 오케스트레이션 설계

---

(개인별 맞춤 설정 확인: 최고 수석 아키텍트의 전문적인 톤을 기반으로, 챕터 번호 생략, 전문 용어의 원문/한글 해석/이니셜 괄호 표기, 상세 주석 제공, AWS ECR 과금 유의 표기, 깃허브 마크다운 적용, 단답형 Next Step, 책 페이지 분량 등 지시하신 모든 개인화 요구사항을 완벽하게 검토 및 적용하였습니다.)
