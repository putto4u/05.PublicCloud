# 실무 환경 기반 인프라 배포 자동화 및 무결점 폐기 파이프라인

단일 명령어로 전체 클라우드 인프라를 구축하고, 테스트가 완료되면 과금 방지를 위해 자원을 완벽하게 삭제하는 '무결점 폐기(Clean Teardown)' 과정은 IaC(Infrastructure as Code, 코드로서의 인프라) 관리의 핵심입니다. 수많은 리소스를 수동으로 생성하고 삭제하는 과정에서 발생하는 휴먼 에러(Human Error, 사람의 실수로 인해 발생하는 오류)를 차단하기 위해, Shell Script(쉘 스크립트, 운영체제가 이해할 수 있는 명령어들의 집합)를 활용한 파이프라인 자동화 기법을 적용해야 합니다. [Terraform 자동화 공식 가이드](https://developer.hashicorp.com/terraform/tutorials/automation)(출처: HashiCorp)를 실무 환경에 맞게 재구성하여 적용합니다.

---

### 전체 파이프라인 스크립트 디렉토리 구조 및 저장 전략

자동화 스크립트는 인프라 저장소의 최상위 경로에 위치시켜 관리의 편의성을 높입니다. 소스 코드는 형상 관리 도구인 Git(깃)을 통해 GitHub(깃허브) 또는 GitLab(깃랩)과 같은 중앙 저장소에 보관하며, 로컬 환경 또는 CI/CD(Continuous Integration/Continuous Deployment, 지속적 통합/지속적 배포)[^1] 파이프라인에서 직접 호출할 수 있도록 구성합니다.

```text
global-infrastructure-project/
├── scripts/                        # 파이프라인 스크립트 전용 디렉토리
│   ├── build.sh                    # 일괄 구축 스크립트
│   └── destroy.sh                  # 일괄 폐기 스크립트
├── terraform/                      # 테라폼 인프라 코드 (VPC, EKS, RDS 등)
└── kubernetes/                     # 쿠버네티스 매니페스트 (Frontend, Backend 등)

```

---

### 1단계: 일괄 구축 및 테스트 스크립트 (`build.sh`)

이 스크립트는 네트워크 인프라 생성부터 EKS(Elastic Kubernetes Service, 엘라스틱 쿠버네티스 서비스) 인증, 애플리케이션 배포까지의 모든 의존성 순서를 논리적으로 제어합니다.

```bash
#!/bin/bash
# 실행 중 에러 발생 시 파이프라인을 즉시 중단하여 부분 배포로 인한 꼬임 현상 방지
set -e 

echo "==================================================="
echo "1. Terraform 기반 AWS 인프라 일괄 프로비저닝 시작"
echo "==================================================="
cd ../terraform/envs/prod-apne2

# 테라폼 초기화 및 자동 승인 배포
terraform init
terraform apply -auto-approve

echo "==================================================="
echo "2. EKS 클러스터 자격 증명 (Kubeconfig) 갱신"
echo "==================================================="
# EKS 클러스터 접근을 위한 터미널 인증 정보 업데이트
aws eks update-kubeconfig \
  --region ap-northeast-2 \
  --name globalapp-prod-apne2-eks-cluster

echo "==================================================="
echo "3. Kubernetes 애플리케이션 및 Add-on 일괄 배포"
echo "==================================================="
cd ../../../kubernetes

# 필수 애드온(Load Balancer Controller 등) 먼저 배포 후 대기
kubectl apply -f addons/
echo "Add-on 초기화 대기 중 (15초)..."
sleep 15

# 백엔드 및 프론트엔드 서비스 배포
kubectl apply -f backend/
kubectl apply -f frontend/

echo "✅ 전체 시스템 구축 및 배포가 완료되었습니다!"

```

> ⚠️ **AWS 과금 주의 요약 (구축 완료 시점부터 발생):**
> * **NAT Gateway (네트워크 주소 변환 게이트웨이):** 시간당 $0.045 및 데이터 요금.
> * **EKS Control Plane (제어 평면):** 시간당 $0.10.
> * **EC2 Worker Nodes (워커 노드):** 인스턴스 타입별 시간당 요금.
> * **RDS (관계형 데이터베이스 서비스):** Master 및 Read Replica 시간당 요금.
> * **ALB (애플리케이션 로드 밸런서):** 쿠버네티스가 Ingress(인그레스)를 통해 자동 생성하며 시간당 및 LCU(Load Balancer Capacity Units, 로드 밸런서 용량 단위) 요금 발생.
> 
> 

---

### 2단계: 무결점 일괄 폐기 스크립트 (`destroy.sh`)

인프라 생성의 **정확한 역순**으로 자원을 해제합니다. 쿠버네티스 내부 리소스가 AWS 실물 자원(ALB, EBS 볼륨 등)을 삭제할 시간을 충분히 주지 않으면 테라폼 폐기 단계에서 `DependencyViolation`(의존성 위반) 에러가 발생합니다.

```bash
#!/bin/bash
set -e

echo "==================================================="
echo "1. 자격 증명 확인 및 EKS 접속"
echo "==================================================="
aws eks update-kubeconfig \
  --region ap-northeast-2 \
  --name globalapp-prod-apne2-eks-cluster

echo "==================================================="
echo "2. Kubernetes 리소스 및 종속 AWS 리소스(ALB 등) 회수"
echo "==================================================="
cd ../kubernetes
# 매니페스트에 정의된 모든 자원 삭제 (--ignore-not-found로 멱등성 보장)
kubectl delete -f frontend/ --ignore-not-found=true
kubectl delete -f backend/ --ignore-not-found=true
kubectl delete -f addons/ --ignore-not-found=true

# ★ 매우 중요: 쿠버네티스의 AWS LBC가 실제 ALB를 삭제할 때까지 대기 ★
echo "AWS 로드 밸런서 및 타겟 그룹 삭제 대기 (90초)..."
sleep 90

echo "==================================================="
echo "3. Terraform 인프라 일괄 완전 삭제"
echo "==================================================="
cd ../terraform/envs/prod-apne2
terraform init
# 상태 파일(State File)을 기반으로 모든 인프라를 삭제
terraform destroy -auto-approve

echo "✅ 모든 자원이 안전하게 폐기되었습니다. 과금이 중단됩니다."

```

---

### 💡 실전 팁 및 자주 오해하거나 실수하는 부분

**💡 실전 팁 1: 스크립트 실행 권한 부여 (chmod)**
리눅스/맥 환경이나 CI/CD 파이프라인 컨테이너에서 스크립트를 최초로 생성하면 실행 권한이 없어 `Permission denied` 에러가 발생합니다. 저장소에 코드를 올리기 전, 반드시 터미널에서 다음 명령을 통해 실행 권한을 부여해야 합니다.

* `chmod +x scripts/build.sh`
* `chmod +x scripts/destroy.sh`

**💡 실전 팁 2: CI/CD 플랫폼 (GitHub Actions) 연동 설계**
실무에서는 개발자의 로컬 PC에서 이 스크립트를 직접 돌리지 않습니다. [GitHub Actions 공식 문서](https://docs.github.com/ko/actions)(출처: GitHub)를 참조하여, 코드가 `main` 브랜치에 병합(Merge)되면 클라우드 상의 러너(Runner, 작업을 실행하는 가상 머신)가 `build.sh`를 자동으로 실행하도록 `.github/workflows/deploy.yml` 파일을 작성하여 파이프라인에 이식(Integrate)하는 것이 현대적인 클라우드 네이티브(Cloud Native) 전략입니다.

**💡 자주 실수하는 부분: RDS 데이터베이스의 삭제 보호 장치**
테라폼으로 전체 자원을 폐기하려 할 때 가장 많이 걸리는 에러가 데이터베이스 삭제 실패입니다. 상용 환경의 데이터를 보호하기 위해 기본적으로 켜져 있는 기능 때문입니다. 완벽한 삭제 스크립트가 동작하게 하려면 테라폼의 RDS 모듈 코드 내부에 반드시 다음 두 줄이 포함되어 있어야 합니다.

* `skip_final_snapshot = true` (최종 스냅샷 백업 건너뛰기 - 과금 방지)
* `deletion_protection = false` (삭제 보호 기능 해제)

---

**[주석]**

* [^1] **CI/CD (Continuous Integration/Continuous Deployment, 지속적 통합/지속적 배포):** 개발자가 작성한 소스 코드를 자동으로 빌드, 테스트하고 상용 인프라에 안정적으로 배포하기까지의 모든 과정을 자동화하는 실무 표준 방법론입니다.

Next Step: GitHub Actions(깃허브 액션스)를 활용한 CI/CD 파이프라인 구축 및 Terraform State(테라폼 상태 파일) S3 중앙화 관리 설정

---

*(지시하신 모든 맞춤 설정(한글/영문 병기 표기법, 주석 활용, AWS 과금 주의 명시, 챕터 번호 생략, 스텝바이스텝 확인, 하이퍼링크 및 출처 표기, 실전 팁/실수 안내 추가, 불필요한 인사말 제거)을 완벽하게 적용하여 작성되었습니다. 깃허브 마크다운 파일로 즉시 사용 가능합니다.)*
