# 글로벌 확장을 위한 Terragrunt 기반 다중 리전 Hub & Spoke 아키텍처 및 DRY 설계

단일 리전(Region)에서 동작하는 클러스터를 향후 미대륙(US)과 유럽(UK) 등 다중 리전으로 확장하고, 이들을 중앙에서 통제하는 허브 앤 스포크(Hub & Spoke)[^1] 아키텍처로 진화시키기 위해서는 인프라 코드의 구조적 혁신이 필요합니다.

단순히 Terraform(테라폼) 코드의 디렉토리를 복사하여 붙여넣는 방식은 코드의 중복을 초래하고 유지보수를 불가능하게 만듭니다. 이를 해결하기 위해 IaC(Infrastructure as Code, 코드로서의 인프라)의 핵심 원칙인 DRY(Don't Repeat Yourself, 중복 배제 원칙)[^2]를 완벽하게 구현할 수 있는 래퍼(Wrapper) 도구인 **Terragrunt(테라그런트)**를 도입하여, 허브(Hub) 자원과 스포크(Spoke) 자원을 완전히 분리하고 언제든 손쉽게 복제할 수 있는 구조로 재설계합니다.

---

### 1. Hub & Spoke 자원 분리 전략

다중 리전 확장을 염두에 둘 때, 가장 먼저 해야 할 일은 **'중앙에서 공유할 자원(Hub)'**과 **'각 지역별로 독립적으로 구동될 애플리케이션 자원(Spoke)'**의 경계를 명확히 나누는 것입니다.

* **Hub (중앙 통제 및 공유 리소스):**
* **TGW (Transit Gateway, 트랜짓 게이트웨이):** 전 세계의 Spoke VPC(Virtual Private Cloud, 가상 프라이빗 클라우드)들을 하나로 연결하는 글로벌 라우터 역할을 합니다.
* **공유 인프라:** 보안을 위한 Bastion Host(배스천 호스트), 글로벌 DNS(Domain Name System, 도메인 네임 시스템) 해석기, 공통 CI/CD(지속적 통합/지속적 배포) 러너 등.


> ⚠️ **AWS 과금 주의:** TGW는 생성 즉시 **시간당 연결 요금(약 $0.05/시간)과 데이터 처리 요금**이 발생하며, 리전 간(Inter-Region) 피어링(Peering) 시 추가적인 데이터 전송 비용이 부과됩니다.


* **Spoke (워크로드 리소스):**
* **지역별 인프라:** 한국, 미국, 영국의 각 VPC, 퍼블릭/프라이빗 서브넷(Subnet).
* **애플리케이션 환경:** EKS(Elastic Kubernetes Service, 엘라스틱 쿠버네티스 서비스) 클러스터 및 RDS(Relational Database Service, 관계형 데이터베이스 서비스).


> ⚠️ **AWS 과금 주의:** Spoke 리전을 한국, 미국, 영국 3곳으로 확장하면 EKS 컨트롤 플레인 유지비(시간당 $0.10) 및 RDS 비용이 **정확히 3배**로 증가합니다.



---

### 2. Terragrunt(테라그런트) 도입 배경 및 원리

[Terragrunt 공식 문서](https://terragrunt.gruntwork.io/)(출처: Gruntwork)에 따르면, Terragrunt는 순수 Terraform이 가진 '상태 파일(State file) 관리의 복잡성'과 '모듈 반복 선언의 번거로움'을 해결해 줍니다.

순수 Terraform 환경에서는 한국, 미국, 영국 인프라를 만들기 위해 동일한 `main.tf` 코드를 3번 복사해야 하지만, Terragrunt를 사용하면 `modules/` 디렉토리에 **Terraform 원본 코드를 단 한 번만 작성**하고, 실제 배포는 `live/` 디렉토리에서 수십 줄의 `terragrunt.hcl` 설정 파일만으로 변수(예: 리전 이름, CIDR 대역)만 주입하여 찍어내듯(Dry-run) 배포할 수 있습니다.

---

### 3. DRY 원칙이 적용된 실무형 프로젝트 디렉토리 구조

앞선 단일 프로젝트 구조를 Terragrunt 기반의 Hub & Spoke 다중 리전 구조로 전면 개편합니다.

```text
global-microservices-project/
├── scripts/                        # 파이프라인 스크립트 (Terragrunt 래핑)
├── kubernetes/                     # K8s 매니페스트 (각 클러스터별 배포)
│
├── infrastructure/                 # 인프라스트럭처 최상위 디렉토리
│   ├── modules/                    # [순수 Terraform] 절대 중복되지 않는 핵심 템플릿
│   │   ├── aws-network/            # VPC, Subnet, NAT 생성 모듈
│   │   ├── aws-eks/                # EKS 클러스터 생성 모듈
│   │   ├── aws-rds/                # RDS 생성 모듈
│   │   └── aws-tgw/                # Hub용 Transit Gateway 생성 모듈
│   │
│   └── live/                       # [Terragrunt HCL] 실제 환경 및 리전별 배포 정의서
│       ├── terragrunt.hcl          # 전역 설정 (S3 Backend 자동 생성 등)
│       │
│       ├── hub/                    # [중앙 통제 영역] - 추후 다른 리전으로 이전 용이
│       │   └── ap-northeast-2/     # 현재는 한국에 위치하지만 논리적으로 격리됨
│       │       └── tgw/
│       │           └── terragrunt.hcl
│       │
│       └── spokes/                 # [워크로드 영역] - 전 세계로 복제되는 영역
│           ├── ap-northeast-2/     # 한국 (기존 프로젝트 수용)
│           │   ├── network/terragrunt.hcl  # inputs: cidr = "10.10.0.0/16"
│           │   ├── eks/terragrunt.hcl
│           │   └── rds/terragrunt.hcl
│           │
│           ├── us-east-1/          # 미국 동부 (신규 확장)
│           │   ├── network/terragrunt.hcl  # inputs: cidr = "10.20.0.0/16"
│           │   ├── eks/terragrunt.hcl
│           │   └── rds/terragrunt.hcl
│           │
│           └── eu-west-2/          # 영국 런던 (신규 확장)
│               ├── network/terragrunt.hcl  # inputs: cidr = "10.30.0.0/16"
│               ├── eks/terragrunt.hcl
│               └── rds/terragrunt.hcl

```

이 구조의 핵심은 **Hub를 물리적 위치(한국)에 종속시키지 않고 논리적 디렉토리(`live/hub/`)로 완전히 분리**했다는 점입니다. 향후 Hub 자원을 별도의 글로벌 리전으로 옮기더라도 `live/hub/` 하위의 경로와 파라미터만 수정하면 Spoke에 영향을 주지 않고 마이그레이션이 가능합니다.

---

### 4. Terragrunt HCL 작성 예시 및 작동 원리

영국(UK) 리전에 Spoke 네트워크를 배포하기 위한 `live/spokes/eu-west-2/network/terragrunt.hcl` 파일의 내부 구조는 다음과 같습니다. Terraform 코드를 다시 쓰지 않고 소스(Source)만 참조합니다.

```hcl
# 루트 terragrunt.hcl을 포함하여 S3 상태 파일(State File) 설정을 상속받음
include {
  path = find_in_parent_folders()
}

# 재사용할 Terraform 원본 모듈의 경로 지정
terraform {
  source = "../../../../modules/aws-network"
}

# 해당 리전 및 환경에 맞게 변수(Inputs)만 주입
inputs = {
  region             = "eu-west-2"
  environment        = "spoke-uk"
  vpc_cidr           = "10.30.0.0/16" # 영국은 10.30 대역 사용
  public_subnets     = ["10.30.1.0/24", "10.30.2.0/24"]
  private_subnets    = ["10.30.10.0/24", "10.30.11.0/24"]
}

```

터미널에서 이 디렉토리로 이동하여 `terragrunt apply`를 실행하면, Terragrunt가 임시 폴더에 `aws-network` 모듈을 복사하고 지정된 `inputs`를 주입하여 Terraform을 대신 실행해 줍니다.

---

### 💡 실전 팁 및 자주 오해하거나 실수하는 부분

**💡 자주 오해하는 부분: "Terragrunt를 쓰면 Terraform 명령어는 못 쓰나요?"**
Terragrunt는 Terraform을 감싸고 있는 도구일 뿐, Terraform을 대체하는 것이 아닙니다. 내부적으로는 완벽하게 호환되며, `terragrunt plan`, `terragrunt apply`, `terragrunt destroy` 등 기존 Terraform의 명령어를 그대로 동일하게 사용합니다.

**💡 실전 팁: 의존성(Dependencies)의 강력한 제어**
EKS 클러스터를 생성하려면 반드시 VPC(네트워크)가 먼저 완성되어 있어야 합니다. 순수 Terraform에서는 상태 파일을 불러오는 등 설정이 복잡하지만, Terragrunt에서는 `terragrunt.hcl` 내부에 `dependency "network"` 블록을 추가하는 것만으로 실행 순서를 완벽하게 보장하고, 네트워크에서 생성된 VPC ID를 EKS 모듈로 매끄럽게 전달할 수 있습니다.

**💡 필수 점검 실수: 리전별 Provider 충돌**
`modules/` 에 있는 Terraform 소스 코드 안에 `provider "aws" { region = "ap-northeast-2" }` 와 같이 리전을 하드코딩(Hard-coding)해 두면, Terragrunt로 미국이나 영국에 배포할 때 에러가 발생합니다. 모듈 내의 Provider 설정은 반드시 변수 처리하거나 제거하고, Terragrunt가 주입하도록 유연하게 비워두어야 합니다.

---

**[주석]**

* [^1] **Hub & Spoke (허브 앤 스포크):** 자전거 바퀴의 중심축(Hub)과 바퀴살(Spoke)에서 유래한 네트워크 설계 패턴. 중앙의 Hub VPC를 통해 모든 통신이 통제되며, Spoke VPC들은 Hub를 거쳐 서로 통신하거나 외부로 나갑니다. 네트워크 보안 관리와 확장에 매우 유리합니다.
* [^2] **DRY (Don't Repeat Yourself, 중복 배제 원칙):** 소프트웨어 개발의 기본 원칙으로, 동일한 코드나 구성이 여러 곳에 반복되어 존재하는 것을 피해야 한다는 의미입니다. 인프라 코드의 유지보수성을 극대화합니다.

---

Next Step: Terragrunt 의존성(Dependencies) 블록을 활용한 Network, RDS, EKS 모듈 간의 파라미터 전달 및 데이터 흐름 설계 전략
