### 실무 환경 디렉토리 생성 및 일일 작업(Daily Workflow) 파이프라인 가이드 (Project: awskr01)

앞서 정의한 코드를 바탕으로, 실제 환경에서 어디에 폴더를 만들고 파일을 어떻게 위치시켜야 하는지 물리적인 작업 절차를 안내합니다. 아울러 클라우드 과금을 방지하기 위해 매일 작업을 시작할 때 인프라를 올리고, 작업이 끝나면 코드를 저장(Git Commit)한 뒤 모두 파괴(Destroy)하고 퇴근하는 실무형 일일 파이프라인(Daily Pipeline) 실행 방법을 구성합니다.

---

### 작업 환경 준비: 로컬 PC(Local PC) 기반의 IaC 개발 환경 세팅

최초의 인프라스트럭처 에즈 코드(IaC - Infrastructure as Code) 작성 및 실행 작업은 AWS 상의 EC2(Elastic Compute Cloud, 탄력적 컴퓨팅 클라우드) 인스턴스를 별도로 만들어서 진행하는 것이 아닙니다. 코딩의 편의성(VS Code 등 에디터 활용)과 불필요한 서버 유지 비용(과금)을 방지하기 위해, **작업자의 로컬 PC(MacBook, Windows Git Bash, 리눅스 터미널 등)에서 직접 수행**하는 것이 글로벌 실무의 표준입니다.

작업을 시작하기 전, 로컬 PC 터미널에 다음 도구들이 설치되어 있고 AWS 계정과 연동되어 있어야 합니다.

1. **AWS CLI(Command Line Interface, 명령줄 인터페이스):** AWS 자원을 제어하기 위한 도구입니다. 로컬 PC에 설치한 후 터미널에서 `aws configure` 명령어를 입력하여 IAM(Identity and Access Management, 식별 및 액세스 관리) 관리자 권한을 가진 사용자의 Access Key(액세스 키)와 Secret Key(시크릿 키)를 등록해야 테라폼이 AWS에 접근할 수 있습니다.
2. **Terraform(테라폼) 및 Terragrunt(테라그런트):** 인프라 코드를 실행하는 핵심 바이너리 파일입니다. 로컬 PC의 환경 변수(Path)에 등록되어 터미널 어디서든 실행 가능해야 합니다.
3. **Git(깃):** 코드 형상 관리를 위한 필수 버전 제어 시스템입니다.

---

### 작업 공간 초기화 및 디렉토리 생성 (터미널 작업)

가장 먼저 프로젝트의 뼈대가 될 디렉토리 구조를 생성해야 합니다. 터미널을 열고 로컬 PC의 본인 작업 공간(예: `~/workspace` 또는 `C:\workspace`)으로 이동한 뒤 아래 명령어들을 순차적으로 실행하여 폴더들을 생성합니다.

```bash
# 1. 최상위 프로젝트 폴더 생성 및 이동
mkdir -p awskr01
cd awskr01

# 2. 인프라 모듈(순수 테라폼) 및 Live(테라그런트) 디렉토리 생성
mkdir -p infrastructure/modules/prepare
mkdir -p infrastructure/live/000-prepare/ap-northeast-2

# 3. 형상 관리를 위한 Git 초기화
git init
# 현재 브랜치(master)의 이름을 main으로 변경
git branch -m master main

```

---

### 각 파일별 정확한 생성 위치 및 코드 삽입

생성된 디렉토리에 맞게 앞서 설계했던 사전 작업(Prepare)의 전체 코드를 아래에 통합하여 제공합니다. VS Code 등의 에디터를 사용하여 지정된 경로에 정확히 파일을 생성하고 코드를 작성하십시오.

**파일 1: 최상위 전역 상태 설정 파일**

* **생성 위치:** `infrastructure/live/terragrunt.hcl`
* **작업 내용:** 하위의 모든 디렉토리(Spoke, Hub 등)가 공통으로 상속받는 전역 상태 파일 설정입니다. S3(Simple Storage Service, 단순 스토리지 서비스) 버킷 이름은 반드시 전 세계에서 유일한 이름으로 수정해야 합니다.

```hcl
remote_state {
  backend = "s3"
  generate = {
    path      = "backend.tf"
    if_exists = "overwrite_terragrunt"
  }
  config = {
    # 과금 주의: S3 버킷에 상태 파일이 저장되며, 저장된 용량 및 요청 횟수에 따라 소액의 종량제 요금이 발생합니다.
    bucket         = "awskr01-tfstate-apne2-12345" # 본인만의 고유한 이름으로 변경 필수
    key            = "${path_relative_to_include()}/terraform.tfstate"
    region         = "ap-northeast-2"
    encrypt        = true
    
    # 과금 주의: 동시성 제어를 위한 DynamoDB 테이블이 생성되며, 읽기/쓰기 용량에 따른 요금이 발생합니다.
    dynamodb_table = "awskr01-tflock-table"
  }
}

# 모든 리소스에 공통으로 들어갈 글로벌 태그 정의
inputs = {
  default_tags = {
    Project     = "awskr01-Hub-Spoke"
    ManagedBy   = "Terragrunt"
  }
}

```

**파일 2: 사전 작업 모듈 파일 (순수 테라폼)**

* **생성 위치:** `infrastructure/modules/prepare/main.tf`
* **작업 내용:** ECR(Elastic Container Registry, 엘라스틱 컨테이너 레지스트리) 저장소 생성 및 EKS(Elastic Kubernetes Service, 엘라스틱 쿠버네티스 서비스) 클러스터용 IAM 역할 생성 코드를 이 파일에 저장합니다.

```terraform
# 1. ECR (Elastic Container Registry) 생성
# 프론트엔드와 백엔드의 도커(Docker) 이미지를 저장할 중앙 보관소입니다.
# 과금 주의: ECR은 저장된 이미지의 용량(GB당 월 $0.10) 및 데이터 전송량에 따라 과금이 발생합니다.

# 백엔드용 이미지 저장소 정의
resource "aws_ecr_repository" "backend_repo" {
  name                 = "awskr01-backend" # 저장소 이름 설정
  image_tag_mutability = "MUTABLE"           # 이미지 태그 변경 가능 여부 (MUTABLE: 동일 태그 덮어쓰기 허용)

  # 이미지 보안 설정
  image_scanning_configuration {
    scan_on_push = true # 이미지가 푸시(Push)될 때마다 보안 취약점을 자동으로 스캔함
  }
}

# 프론트엔드용 이미지 저장소 정의
resource "aws_ecr_repository" "frontend_repo" {
  name                 = "awskr01-frontend"
  image_tag_mutability = "MUTABLE"
}


# 2. EKS Cluster IAM Role
# 쿠버네티스 컨트롤 플레인(Control Plane)이 AWS 인프라(EC2, 로드밸런서 등)를 제어하기 위해 필요한 권한입니다.
# EKS 클러스터용 IAM Role(Identity and Access Management Role, 신뢰 관계 설정) 생성
resource "aws_iam_role" "eks_cluster_role" {
  name = "awskr01-eks-cluster-role"

# 이 역할(Role)을 누구(EKS 서비스)가 사용할 수 있는지 정의하는 신뢰 정책
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"   # sts 토큰,  역할을 맡을 수 있도록 허용하는 동작
      Effect = "Allow"
      Principal = {
        Service = "eks.amazonaws.com"  # EKS 서비스가 이 역할을 사용하도록 지정
      }
    }]
  })
}

# 생성한 역할에 실제 권한(Policy) 부여
# AWS IAM 역할에 특정 정책(Policy)을 부착(Attachment)하는 리소스 정의
resource "aws_iam_role_policy_attachment" "eks_cluster_policy" {
  # AmazonEKSClusterPolicy: EKS 클러스터가 AWS 리소스를 관리하는 데 필요한 표준 권한 ARN(Amazon Resource Name)
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
  
  # 위에서 정의한 aws_iam_role.eks_cluster_role 리소스의 이름을 참조하여 해당 역할에 권한을 연결
  role       = aws_iam_role.eks_cluster_role.name 
}

```

**파일 3: 한국 리전 사전 작업 실행 파일 (테라그런트)**

* **생성 위치:** `infrastructure/live/000-prepare/ap-northeast-2/terragrunt.hcl`
* **작업 내용:** 최상위 설정을 상속(`include`)받고, 모듈의 경로(`source`)를 연결하는 코드를 이 파일에 저장합니다.

```hcl
# 현재 위치에서 상위 폴더를 거슬러 올라가며 최상위 terragrunt.hcl(S3/DynamoDB 설정)을 찾아 상속받음
include {
  path = find_in_parent_folders()
}

# 실제 인프라 리소스를 정의한 테라폼 모듈 소스 코드의 상대 경로를 지정
terraform {
  source = "../../../../modules/prepare"
}

# 해당 모듈의 variables.tf에 정의된 변수들에 실제 값을 주입하는 블록
inputs = {
  # 리소스가 생성될 AWS 지역을 서울 리전으로 지정
  region      = "ap-northeast-2"
  
  # 현재 환경의 식별자 이름을 프로젝트 명칭에 맞춰 설정
  environment = "awskr01-prepare"
}
```

---

### 실행 방법: 작업 시작 및 테스트 (Day 1 - Start)

파일 배치가 완료되었으면, 해당 리전의 `live` 디렉토리로 이동하여 테라그런트 명령어를 통해 AWS 상에 리소스를 실제 프로비저닝(Provisioning)하고 테스트합니다.

```bash
# 1. 실행할 대상 디렉토리로 이동
cd infrastructure/live/000-prepare/ap-northeast-2

# 2. 테라그런트 초기화 (플러그인 다운로드 및 S3/DynamoDB 백엔드 자동 생성)
terragrunt init

# 3. 배포 계획 확인 및 실제 배포 적용
# 과금 주의: 이 명령어가 성공하면 S3, DynamoDB, ECR 등이 생성되어 과금이 시작될 수 있습니다.
terragrunt apply

```

* 명령어 실행 중 `Are you sure you want to perform these actions?` 라는 프롬프트가 나오면 `yes`를 입력하여 승인합니다.
* 에러 없이 `Apply complete!` 메시지가 나오면 AWS 콘솔에 접속하여 IAM Role과 ECR 리포지토리가 잘 만들어졌는지 테스트 및 확인합니다.

---

### 일일 작업 종료 및 과금 방지 파이프라인 (Day 1 - End)

작업과 테스트가 무사히 끝났다면, 불필요한 과금을 막기 위해 생성된 자원을 모두 파괴하고 현재까지의 코드를 Git에 안전하게 저장합니다.

```bash
# 1. 인프라 자원 안전하게 일괄 폐기 (과금 중단)
# 이 명령을 실행해도 우리가 작성한 로컬의 '코드'는 지워지지 않으며, AWS 상의 '실물 자원'만 지워집니다.
terragrunt destroy

```

* `yes`를 입력하여 폐기를 승인합니다. `Destroy complete!`를 반드시 확인하십시오.
* **참고:** `terragrunt destroy`를 하더라도 중앙 상태 관리를 위해 Terragrunt가 자동으로 만든 최상위 S3 버킷과 DynamoDB 테이블은 안전을 위해 삭제되지 않고 유지됩니다. (이 유지 비용은 월 1달러 미만의 극소액입니다.)

```bash
# 2. 작업 폴더 최상단으로 이동
cd ../../../../

# 3. 오늘 작업한 코드를 Git(형상 관리 저장소)에 저장
git add .
git commit -m "feat: 000-prepare 모듈 및 terragrunt 설정 완료"
git push origin main  # 깃허브 저장
```

---

### 다음 날 작업 이어서 하기 (Day 2 - Start)

다음 날 다시 로컬 PC를 켜고, 어제 폐기했던 인프라를 다시 살려낸 뒤 그 위에서 다음 단계(예: 020-spokes 네트워크 구축)의 코딩과 테스트를 이어나가는 파이프라인입니다.

```bash
# 1. 어제 작업했던 디렉토리로 이동하여 인프라 즉시 복구 (멱등성 보장)
cd infrastructure/live/000-prepare/ap-northeast-2
terragrunt apply -auto-approve

# 2. 인프라가 완벽히 어제 상태로 복원되었으므로, 다음 단계 폴더 생성 후 작업 진행
cd ../../
mkdir -p 020-spokes/ap-northeast-2/network
# ... (다음 단계 코딩 시작) ...

```

이와 같은 **"로컬 PC에서 코드 작성 -> 배포(Apply) 및 테스트 -> 형상 관리(Commit) -> 자원 파괴(Destroy)"**의 반복적인 사이클(Cycle)이 클라우드 네이티브(Cloud Native) 엔지니어들이 막대한 과금을 피하면서도 대규모 인프라를 안전하게 설계하는 실무의 핵심 파이프라인입니다.

---

Next Step: 단일 스포크(Spoke) VPC 구축 및 NAT Gateway 동적 토글(Toggle)을 적용한 네트워크 모듈 구성 및 적용 방법

---

### 인프라스트럭처 실행 메커니즘: Terragrunt의 상속과 실행 원리

질문하신 **`infrastructure/live/terragrunt.hcl`**과 **`main.tf`**는 별도로 독립 실행하는 파일이 아니라, `terragrunt apply` 명령을 내리는 순간 **자동으로 결합되어 실행**됩니다. 그 작동 원리를 이해하는 것이 중요합니다.

---

### 1. `infrastructure/live/terragrunt.hcl` (최상위 설정)은 어떻게 실행되나?

이 파일은 **"설정의 부모"** 역할을 합니다.

* **실행 방식:** 우리가 `infrastructure/live/000-prepare/ap-northeast-2/` 디렉토리에서 `terragrunt apply`를 실행하면, 해당 폴더의 `terragrunt.hcl` 안에 있는 `include { path = find_in_parent_folders() }` 코드가 작동합니다.
* **결과:** Terragrunt는 상위 폴더를 뒤져서 최상위 `terragrunt.hcl`을 찾아냅니다. 그리고 그 안에 정의된 **S3 Backend(백엔드) 설정과 전역 변수(Inputs)**를 현재 실행 위치로 가져와서 합쳐버립니다.
* 따라서, 하위 디렉토리에서 명령을 내리는 것만으로 최상위 설정은 **이미 적용되고 있는 상태**입니다.

---

### 2. `infrastructure/modules/prepare/main.tf` (모듈 코드)는 어떻게 실행되나?

이 파일은 **"설계도"**이며, Terragrunt에 의해 **임시 작업 공간으로 복사**되어 실행됩니다.

* **실행 방식:** 하위 `terragrunt.hcl`의 `terraform { source = "..." }` 설정을 통해 Terragrunt는 `main.tf`가 있는 위치를 파악합니다.
* **결과:** `terragrunt apply`를 입력하면 Terragrunt는 다음 과정을 순식간에 처리합니다.
1. `.terragrunt-cache`라는 숨겨진 임시 폴더를 만듭니다.
2. 그 안에 `modules/prepare/main.tf` 코드를 복사해 넣습니다.
3. 최상위 설정에서 생성하라고 지시한 `backend.tf` 파일을 그 자리에 생성합니다.
4. 그 폴더 안에서 실제 `terraform apply`를 대신 호출합니다.



> **핵심 요약:** 우리가 `live` 폴더의 가장 끝단(Leaf Directory)에서 명령을 내리는 이유는, 그곳이 **설계도(Module)**와 **환경 설정(Root Config)**이 만나서 **실제 자원(Instance)**으로 탄생하는 접점이기 때문입니다.

---

### 3. 일일 작업 시 주의사항 (과금 및 무결성)

* **`terragrunt init`의 중요성:** 최상위 `terragrunt.hcl`의 S3 버킷 이름 등을 변경했다면, 반드시 다시 `init`을 해주어야 백엔드 구성이 동기화됩니다.
* **과금 포인트:** `main.tf`에 정의된 **ECR(Elastic Container Registry, 엘라스틱 컨테이너 레지스트리)** 저장소 자체는 생성 시 비용이 거의 없으나, 나중에 이미지를 푸시하여 저장 용량이 늘어나면 비용이 발생합니다.
* **DynamoDB 테이블:** Terragrunt가 상태 잠금(Locking)을 위해 만드는 DynamoDB는 **`terragrunt destroy`를 해도 삭제되지 않습니다.** 하지만 프리티어 범위 내에서 거의 무상으로 유지되므로 걱정하지 않으셔도 됩니다.

Next Step: 단일 스포크(Spoke) VPC 구축을 위한 `infrastructure/modules/aws-network-spoke` 모듈 작성 및 변수 처리 방법
