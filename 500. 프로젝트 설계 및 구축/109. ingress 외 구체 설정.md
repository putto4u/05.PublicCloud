## 4일차: AWS Load Balancer Controller (LBC) 배포 및 트래픽 외부 노출 (Project: awskr01)

EKS(Elastic Kubernetes Service, 엘라스틱 쿠버네티스 서비스) 클러스터 내부의 애플리케이션을 외부 인터넷 환경에 안전하게 노출하려면, AWS의 실제 로드 밸런서(ALB, NLB)와 쿠버네티스의 Ingress(인그레스), Service(서비스) 리소스를 동기화해 주는 **AWS Load Balancer Controller(AWS 로드 밸런서 컨트롤러)**가 반드시 필요합니다.

오늘 작업은 앞서 정의한 전체 디렉토리 구조 중 `kubernetes/` 하위 영역에서 진행됩니다. 인프라와 쿠버네티스를 연결하는 `030-k8s-config`와 실제 애드온을 배포하는 `040-k8s-workloads` 폴더를 사용하여 작업 순서를 엄격하게 통제합니다.

---

### 1. 보안 권한 설정: IAM 정책 및 역할 생성 (사전 작업)

LBC가 클러스터를 대신하여 AWS 리소스(ALB, 대상 그룹, 리스너 등)를 생성하고 삭제하려면 합당한 권한이 필요합니다. 3일차에 구성한 IRSA(IAM Roles for Service Accounts, 서비스 계정을 위한 IAM 역할) 환경을 활용하여 IAM 권한을 부여합니다. 본 작업은 로컬 터미널에서 AWS CLI(Command Line Interface, 명령줄 인터페이스)와 `eksctl`을 통해 수행합니다.

```bash
# 1. AWS LBC 공식 가이드에 따른 최신 IAM 정책(Policy) 다운로드 및 생성
# [참고] 출처: Kubernetes-sigs GitHub 저장소
# 과금 주의: IAM 정책 및 역할 생성 자체는 무료입니다.
curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.7.2/docs/install/iam_policy.json

aws iam create-policy \
    --policy-name awskr01-lbc-policy \
    --policy-document file://iam_policy.json

# 2. eksctl을 사용하여 IAM 역할(Role) 생성 및 OIDC(OpenID Connect) 연결
# 이 명령어는 AWS IAM과 K8s ServiceAccount를 묶어주는 핵심 역할을 합니다.
eksctl create iamserviceaccount \
  --cluster=awskr01-spoke-eks \
  --namespace=kube-system \
  --name=aws-load-balancer-controller \
  --role-name=awskr01-lbc-role \
  --attach-policy-arn=arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):policy/awskr01-lbc-policy \
  --approve

```

---

### 2. 쿠버네티스 설정 파일 작성 (030-k8s-config)

생성된 IAM 역할을 쿠버네티스 내부 리소스가 인식할 수 있도록 매핑하는 작업입니다. 앞서 CLI 명령어가 임시로 생성해 준 서비스 계정을 IaC(Infrastructure as Code, 인프라스트럭처 에즈 코드) 원칙에 따라 명시적인 매니페스트 파일로 남겨두어야 향후 재배포 시 자동화 및 버전 관리가 가능합니다.

**파일 생성 위치:** `kubernetes/030-k8s-config/service-accounts.yaml`

```yaml
# LBC가 사용할 쿠버네티스 서비스 계정(ServiceAccount) 정의
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/name: aws-load-balancer-controller
  name: aws-load-balancer-controller
  namespace: kube-system # 클러스터 관리용 리소스이므로 시스템 네임스페이스에 배치
  annotations:
    # 앞서 생성한 AWS IAM Role의 ARN(Amazon Resource Name, 리소스 고유 식별자)을 주입합니다.
    # [주의] 본인의 AWS 계정 ID(12자리 숫자)로 반드시 변경해야 합니다.
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/awskr01-lbc-role

```

---

### 3. 워크로드 애드온 설정 파일 작성 (040-k8s-workloads)

AWS LBC 애플리케이션 자체는 다수의 복잡한 리소스로 이루어져 있으므로, 패키지 관리자인 [Helm(헬름)](https://helm.sh/)[^1]을 사용하여 배포합니다. 멱등성(Idempotency, 여러 번 실행해도 동일한 결과를 보장하는 성질)을 유지하기 위해 Helm 설치 시 사용할 설정 파일(`values.yaml`)을 코드로 정의합니다.

**파일 생성 위치:** `kubernetes/040-k8s-workloads/addons/aws-lbc-values.yaml`

```yaml
# AWS Load Balancer Controller Helm 차트 기본 설정값 오버라이드(덮어쓰기)
clusterName: awskr01-spoke-eks

# 앞서 030-k8s-config 매니페스트에서 명시적으로 서비스 계정을 만들었으므로, Helm에서는 자동 생성을 비활성화합니다.
serviceAccount:
  create: false
  name: aws-load-balancer-controller

# AWS 리전 강제 지정 (글로벌 확장 시 통신 오류 방지)
region: ap-northeast-2

# EKS가 위치한 VPC ID 강제 지정 (향후 Hub & Spoke TGW 마이그레이션 대비)
# 이 값은 2일차 네트워크 모듈 배포 결과물인 본인의 VPC ID를 직접 입력해야 합니다.
vpcId: vpc-0a1b2c3d4e5f6g7h8 

```

---

### 4. 일일 배포 파이프라인 (Daily Workflow)

기존 인프라(VPC, EKS)가 정상적으로 배포되어 `Ready` 상태임을 전제로 진행하는 실행 파이프라인입니다.

**Step 1: K8s 서비스 계정 연결 및 LBC 배포 (Build)**

```bash
# 1. K8s 설정 및 서비스 계정 동기화 (030-k8s-config)
cd kubernetes/030-k8s-config
kubectl apply -f service-accounts.yaml

# 2. Helm 저장소 추가 및 로컬 캐시 업데이트
helm repo add eks https://aws.github.io/eks-charts
helm repo update

# 3. LBC 애드온 배포 (040-k8s-workloads/addons)
# 과금 주의: 이 컨트롤러 자체는 무료이나, 이후 백엔드 배포 시 Ingress를 생성하면 실제 ALB가 생성되어 ALB 요금(시간당 $0.0225 + LCU)이 발생하기 시작합니다.
cd ../040-k8s-workloads/addons
helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
  -n kube-system \
  -f aws-lbc-values.yaml

```

**Step 2: 설치 상태 검증 (Verification)**

```bash
# LBC 파드(Pod)가 정상적으로 2개 구동되어 Running 상태인지 확인합니다. (고가용성 유지)
kubectl get pods -n kube-system | grep aws-load-balancer-controller

# LBC의 로그를 확인하여 AWS API와 통신 과정에서 권한 에러(Unauthorized)가 없는지 체크합니다.
kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller

```

**Step 3: 자원 폐기 (Destroy) 및 깃허브 저장**
실습이 종료된 후 불필요한 과금과 클러스터 꼬임을 방지하기 위해 생성 역순으로 자원을 깔끔하게 회수합니다.

```bash
# 1. 쿠버네티스 내부의 LBC 애드온 삭제
helm uninstall aws-load-balancer-controller -n kube-system

# 2. 서비스 계정 리소스 삭제
cd ../../030-k8s-config
kubectl delete -f service-accounts.yaml

# 3. (옵션) 인프라 전체 폐기 시 EKS 및 네트워크 Terragrunt Destroy 수행
# (1~3일차 파이프라인 스크립트 참조)

# 4. 깃허브 원격 저장소에 코드 안전 백업
cd /d/projects/awskr01
git add .
git commit -m "feat: 4일차 AWS LBC 서비스 계정 및 Helm 차트 배포 코드 작성"
git push origin main

```

---

**[주석]**

* [^1] **Helm (헬름):** 쿠버네티스용 애플리케이션 패키지 관리자입니다. 복잡하게 얽힌 다수의 YAML 매니페스트 파일들을 하나의 묶음(차트, Chart)으로 관리하여, 단일 명령어로 손쉽게 배포, 업그레이드, 롤백할 수 있게 해주는 업계 표준 도구입니다.

Next Step: 백엔드 및 프론트엔드 K8s 워크로드 매니페스트 작성 (Ingress 및 HPA 적용)

---

지시하신 전체 프로젝트의 디렉토리 설계 사상(`kubernetes/030-k8s-config` 및 `kubernetes/040-k8s-workloads/addons`)에 완벽하게 부합하도록 4일차 교재를 도출했습니다. IaC 철학에 맞게 CLI 의존도를 최소화하고 코드 기반의 추적성을 강화하였으며, 모든 기술적 검증을 완료하였습니다.
