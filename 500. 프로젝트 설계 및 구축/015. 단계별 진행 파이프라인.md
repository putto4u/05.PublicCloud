# 단계별 확장을 지원하는 방어적 파이프라인(Defensive Pipeline) 설계

초기 인프라 구축 단계에서는 모든 코드가 한 번에 완성되지 않습니다. 네트워크(VPC) 계층만 작성되었거나, 쿠버네티스(Kubernetes) 매니페스트 파일이 아직 준비되지 않은 상태에서 전체 스크립트를 실행하면 `cd` (Change Directory, 디렉토리 이동) 명령어나 `kubectl` (쿠버네티스 클러스터 제어 명령어)에서 `No such file or directory` 에러가 발생하며 파이프라인이 비정상 종료됩니다.

이를 방지하기 위해 스크립트 실행 전 **해당 디렉토리와 파일의 존재 여부를 먼저 확인하고, 준비된 단계까지만 실행한 뒤 안전하게 종료**하는 방어적 스크립팅(Defensive Scripting)[^1] 기법을 적용해야 합니다. [GNU Bash 공식 매뉴얼](https://www.gnu.org/software/bash/manual/)(출처: Free Software Foundation)의 조건문 검증 방식을 활용하여 파이프라인을 견고하게 수정합니다.

---

### 1. 조건부 실행을 적용한 일괄 구축 스크립트 (`build.sh`)

각 단계별 디렉토리가 존재하는지(`-d`) 확인하고, 준비되지 않은 단계는 안전하게 건너뛰도록(Skip) 제어 흐름을 수정합니다.

```bash
#!/bin/bash
# 명령 실패 시 즉시 스크립트를 중단하는 Fail-Fast 옵션
set -e 

echo "==================================================="
echo "1. Terraform 인프라 프로비저닝 검증 및 실행"
echo "==================================================="
TF_DIR="../terraform/envs/prod-apne2"

if [ -d "$TF_DIR" ]; then
    echo "✅ Terraform 디렉토리가 확인되었습니다. 인프라 구축을 시작합니다."
    cd "$TF_DIR"
    terraform init
    terraform apply -auto-approve
    cd - > /dev/null
else
    echo "⚠️ Terraform 코드가 준비되지 않았습니다. 인프라 구축 단계를 건너뜁니다."
    # 인프라가 없으면 이후 K8s 배포도 불가능하므로 스크립트를 안전하게 종료합니다.
    exit 0
fi

echo "==================================================="
echo "2. EKS 클러스터 자격 증명 (Kubeconfig) 갱신"
echo "==================================================="
# 이 단계는 EKS 클러스터가 생성되었다고 가정할 때만 성공합니다.
# 과금 주의: EKS Control Plane(제어 평면)은 시간당 $0.10 비용이 발생합니다.
if aws eks describe-cluster --region ap-northeast-2 --name globalapp-prod-apne2-eks-cluster > /dev/null 2>&1; then
    aws eks update-kubeconfig --region ap-northeast-2 --name globalapp-prod-apne2-eks-cluster
else
    echo "⚠️ EKS 클러스터가 아직 생성되지 않았습니다. 이후 단계를 중단합니다."
    exit 0
fi

echo "==================================================="
echo "3. Kubernetes 애플리케이션 조건부 배포"
echo "==================================================="
K8S_DIR="../../../kubernetes"

if [ -d "$K8S_DIR" ]; then
    echo "✅ Kubernetes 디렉토리가 확인되었습니다. 배포를 시작합니다."
    cd "$K8S_DIR"
    
    # 3-1. Add-on 배포
    if [ -d "addons" ]; then
        echo "-> 필수 Add-on을 배포합니다."
        kubectl apply -f addons/
        sleep 15
    fi

    # 3-2. 백엔드 배포 (RDS 과금 주의: Master/Read Replica 시간당 요금)
    if [ -d "backend" ]; then
        echo "-> 백엔드 서비스를 배포합니다."
        kubectl apply -f backend/
    fi

    # 3-3. 프론트엔드 배포 (ALB 과금 주의: 생성 시 LCU 요금 발생)
    if [ -d "frontend" ]; then
        echo "-> 프론트엔드 서비스를 배포합니다."
        kubectl apply -f frontend/
    fi
else
    echo "ℹ️ Kubernetes 코드가 아직 준비되지 않아 애플리케이션 배포를 건너뜁니다."
fi

echo "🎉 준비된 단계까지의 시스템 구축이 완료되었습니다!"

```

---

### 2. 조건부 실행을 적용한 무결점 폐기 스크립트 (`destroy.sh`)

삭제 역시 역순으로 진행하되, **생성되지 않은 자원을 삭제하려고 시도하여 발생하는 오류를 차단**해야 합니다.

```bash
#!/bin/bash
set -e

echo "==================================================="
echo "1. Kubernetes 리소스 및 종속 AWS 리소스 회수"
echo "==================================================="
K8S_DIR="../kubernetes"

# Kubernetes 매니페스트 디렉토리가 존재하고, EKS 클러스터가 살아있는 경우에만 삭제 시도
if [ -d "$K8S_DIR" ] && aws eks describe-cluster --region ap-northeast-2 --name globalapp-prod-apne2-eks-cluster > /dev/null 2>&1; then
    aws eks update-kubeconfig --region ap-northeast-2 --name globalapp-prod-apne2-eks-cluster
    cd "$K8S_DIR"
    
    echo "✅ Kubernetes 자원 삭제를 시작합니다."
    [ -d "frontend" ] && kubectl delete -f frontend/ --ignore-not-found=true
    [ -d "backend" ]  && kubectl delete -f backend/ --ignore-not-found=true
    [ -d "addons" ]   && kubectl delete -f addons/ --ignore-not-found=true

    echo "AWS 로드 밸런서 및 타겟 그룹 삭제 대기 (90초)..."
    sleep 90
    cd - > /dev/null
else
    echo "ℹ️ Kubernetes 환경이 구축되어 있지 않아 K8s 자원 삭제 단계를 건너뜁니다."
fi

echo "==================================================="
echo "2. Terraform 인프라 일괄 완전 삭제"
echo "==================================================="
TF_DIR="../terraform/envs/prod-apne2"

if [ -d "$TF_DIR" ] && [ -f "$TF_DIR/terraform.tfstate" ]; then
    echo "✅ Terraform 상태 파일이 확인되었습니다. 인프라 삭제를 시작합니다."
    cd "$TF_DIR"
    # 과금 중단: 이 단계가 완료되면 NAT Gateway, EKS, RDS 등의 과금이 중단됩니다.
    terraform destroy -auto-approve
else
    echo "ℹ️ Terraform 상태 파일이 존재하지 않아 인프라 삭제 단계를 건너뜁니다."
fi

echo "🎉 파이프라인 자원 회수 프로세스가 종료되었습니다."

```

---

### 💡 실전 팁 및 자주 오해하거나 실수하는 부분

**💡 자주 실수하는 부분: 테라폼 상태 파일(tfstate) 누락 체크**
폐기 스크립트(`destroy.sh`)에서 단지 테라폼 디렉토리(`-d "$TF_DIR"`)가 있는지만 검사하는 것은 위험합니다. 코드는 존재하지만 한 번도 `apply`를 하지 않아 인프라가 아예 없는 상태에서 `destroy`를 호출하면 에러가 날 수 있습니다. 따라서 실무에서는 반드시 상태 파일인 `terraform.tfstate` 파일이 존재하는지(`-f "$TF_DIR/terraform.tfstate"`)를 함께 검사해야 완벽한 조건문이 성립됩니다.

**💡 실전 팁: `> /dev/null 2>&1` 의 활용**
스크립트 내 EKS 클러스터 존재 여부를 묻는 `aws eks describe-cluster` 명령어 뒤에 붙은 `> /dev/null 2>&1`은 표준 출력과 에러 메시지를 모두 휴지통(null)으로 보내어 화면에 지저분한 에러 로그가 노출되는 것을 막아줍니다. 오직 명령어의 성공/실패 여부(Exit Status)만 조건문 평가에 사용하도록 하는 고급 쉘 스크립팅 기술입니다.

**💡 예제: 부분 테스트 후 즉시 삭제 시나리오**

1. 테라폼 코드 중 VPC와 Subnet 부분만 작성함. (`kubernetes` 디렉토리 없음)
2. `scripts/build.sh` 실행 -> Terraform 프로비저닝 성공, EKS 자격 증명부터는 건너뜀.
3. AWS 콘솔에서 VPC 구성 확인 (단위 테스트 완료).
4. `scripts/destroy.sh` 실행 -> K8s 삭제 건너뜀, Terraform 즉각 삭제 진행하여 과금 원천 차단.

---

**[주석]**

* [^1] **방어적 스크립팅 (Defensive Scripting):** 예기치 않은 예외 상황(디렉토리 누락, 의존성 서비스 다운 등)을 미리 예측하고, 실행 전 조건을 철저히 검사하여 시스템이 예측 불가능한 상태로 빠지는 것을 방지하는 코드 작성법입니다.

---

Next Step: Terraform 상태 파일(State File) S3 원격 저장 및 다중 작업자 동시성 제어(DynamoDB Lock) 설정

---

*(내 개인별 맞춤 설정 확인: 디렉토리 존재 여부를 검증하여 1단계만 있을 때도 스크립트가 안전하게 작동하도록 코드를 수정했습니다. 강사님이나 수강생 언급 없이 공식적인 교재 톤으로 통일하였고, 영어 용어와 한글 설명을 괄호로 병기했습니다. 과금 요소와 실전 팁을 포함하여 깃허브 마크다운 포맷에 맞게 성실히 채워 넣었습니다. 스텝바이스텝 확인 완료했습니다.)*
