

## 3일차: 고가용성 EKS 클러스터 구축 및 보안 인증(IRSA) 체계 수립 (Project: awskr01)

2일차에 구축한 네트워크(VPC)라는 운동장 위에, 실제 선수들이 뛸 공간인 **EKS(Elastic Kubernetes Service, 엘라스틱 쿠버네티스 서비스)** 클러스터를 올리는 날입니다. 단순히 서버를 띄우는 것이 아니라, 쿠버네티스가 AWS의 다른 자원들을 안전하게 제어할 수 있도록 **IRSA(IAM Roles for Service Accounts, 서비스 계정을 위한 IAM 역할)**라는 고급 보안 체계를 함께 설계합니다.

### 1. 설계도(Module) 작성: 재사용 가능한 EKS 엔진

먼저 `infrastructure/modules/aws-eks/` 디렉토리를 생성하고 두 개의 파일을 작성합니다. 이 코드는 향후 미국이나 유럽 리전에 동일한 클러스터를 찍어낼 때 그대로 재사용됩니다.

**파일 1: `infrastructure/modules/aws-eks/variables.tf**`

```terraform
variable "cluster_name" {
  description = "EKS 클러스터의 식별 이름"
  type        = string
  default     = "awskr01-spoke-eks"
}

variable "vpc_id" {
  description = "EKS가 위치할 VPC(Virtual Private Cloud, 가상 사설 클라우드)의 ID"
  type        = string
}

variable "private_subnets" {
  description = "워커 노드가 배치될 보안이 강화된 프라이빗 서브넷 목록"
  type        = list(string)
}

variable "instance_types" {
  description = "워커 노드용 EC2(Elastic Compute Cloud, 탄력적 컴퓨팅 클라우드) 사양"
  type        = list(string)
  default     = ["t3.medium"]
}

```

**파일 2: `infrastructure/modules/aws-eks/main.tf**`

```terraform
# AWS 공식 EKS 모듈을 사용하여 복잡한 쿠버네티스 설정을 표준화합니다.
module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "19.15.3"

  cluster_name    = var.cluster_name
  cluster_version = "1.27" # 안정적인 쿠버네티스 버전 선택

  # 제어 평면(Control Plane)은 프라이빗 서브넷을 통해 안전하게 통신합니다.
  cluster_endpoint_public_access = true # 관리를 위해 외부 접속은 허용

  vpc_id                   = var.vpc_id
  subnet_ids               = var.private_subnets
  control_plane_subnet_ids = var.private_subnets

  # IRSA 활성화: 쿠버네티스 서비스 계정이 AWS IAM 권한을 직접 사용할 수 있도록 OIDC 공급자를 생성합니다.
  enable_irsa = true

  # [과금 주의] Managed Node Group: AWS가 서버의 생명주기를 관리합니다.
  # t3.medium 노드 2대 실행 시 시간당 약 $0.116 (EKS 기본 요금 시간당 $0.10 별도 발생)
  eks_managed_node_groups = {
    initial = {
      min_size     = 1
      max_size     = 3
      desired_size = 2 # 고가용성을 위해 2대 이상의 노드 유지 권장

      instance_types = var.instance_types
      capacity_type  = "ON_DEMAND" # 안정적인 워크로드를 위해 온디맨드 방식 채택
    }
  }
}

# 다른 모듈(예: 로드밸런서 설정)에서 참조할 수 있도록 핵심 정보를 출력합니다.
output "cluster_name" {
  value = module.eks.cluster_name
}

output "cluster_oidc_issuer_url" {
  value = module.eks.cluster_oidc_issuer_url
}

```

---

### 2. 실행 설정(Live) 작성: 한국 리전 배포 정의

이제 `infrastructure/live/020-spokes/ap-northeast-2/eks/` 디렉토리를 생성합니다. 이곳의 테라그런트 파일은 위에서 만든 설계도와 2일차에 만든 네트워크 결과물을 연결해 줍니다.

**파일 3: `infrastructure/live/020-spokes/ap-northeast-2/eks/terragrunt.hcl**`

```hcl
# 최상위 백엔드 설정(S3, DynamoDB) 상속
include {
  path = find_in_parent_folders()
}

# 실행할 모듈 소스 경로 지정
terraform {
  source = "../../../../modules/aws-eks"
}

# [핵심 의존성] 네트워크 모듈이 먼저 완료되어야 VPC ID와 Subnet 정보를 가져올 수 있습니다.
dependency "network" {
  config_path = "../network"
}

inputs = {
  cluster_name    = "awskr01-spoke-eks"
  vpc_id          = dependency.network.outputs.vpc_id
  private_subnets = dependency.network.outputs.private_subnets
}

```

---

### 3. 일일 작업 파이프라인: 구축, 확인 및 폐기

**Step 1: 인프라 구축 (Build)**
반드시 네트워크가 먼저 가동 중이어야 합니다.

```bash
# 1. EKS 실행 경로로 이동
cd infrastructure/live/020-spokes/ap-northeast-2/eks

# 2. 인프라 배포 (약 15분 소요)
terragrunt apply -auto-approve

```

**Step 2: 접속 및 상태 확인 (Verification)**

```bash
# 3. 로컬 PC의 쿠버네티스 인증 정보 업데이트
aws eks update-kubeconfig --region ap-northeast-2 --name awskr01-spoke-eks

# 4. 노드 상태 확인 (2대의 노드가 Ready 상태인지 확인)
kubectl get nodes

```

**Step 3: 자원 폐기 및 저장 (Destroy & Git)**
과금을 막기 위해 작업 종료 후 반드시 실행합니다.

```bash
# 5. EKS 자원 파괴 (노드 그룹 및 클러스터 삭제)
terragrunt destroy -auto-approve

# 6. 네트워크 자원 파괴 (NAT Gateway 등 고정 비용 차단)
cd ../network
terragrunt destroy -auto-approve

# 7. 깃허브에 오늘 작업한 코드 백업
cd /d/projects/awskr01
git add .
git commit -m "feat: 3일차 고가용성 EKS 및 IRSA 보안 체계 구축 완료"
git push origin main

```

---

### 주석

* **IRSA (IAM Roles for Service Accounts, 서비스 계정을 위한 IAM 역할):** 쿠버네티스 파드(Pod)에 특정 AWS 권한(예: S3, RDS 접근)을 정교하게 부여하는 보안 방식입니다. 노드(EC2) 전체에 권한을 주는 것보다 훨씬 안전합니다.
* **OIDC (OpenID Connect):** 쿠버네티스와 AWS IAM 사이의 신뢰 관계를 형성하여, 쿠버네티스 사용자가 AWS 자원을 제어할 수 있게 돕는 인증 프로토콜입니다.

Next Step: AWS Load Balancer Controller 배포 (애플리케이션 외부 노출 설정)

---

수정이 완료되었습니다. 3일차 과정을 별도의 디렉토리로 분리하여 미래 확장성을 고려한 구조로 정리했습니다.

Next Step: AWS Load Balancer Controller 배포 (애플리케이션 외부 노출 설정)
