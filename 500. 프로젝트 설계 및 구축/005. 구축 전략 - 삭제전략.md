# 클라우드 비용 최적화를 위한 IaC(Infrastructure as Code, 코드로서의 인프라) 생명주기 관리 및 일괄 구축/삭제 전략

클라우드 환경에서 대규모 마이크로서비스 인프라를 실험하고 개발할 때, 가장 위협적인 요소는 '사용하지 않고 방치된 자원으로 인한 불필요한 과금'입니다. 따라서 개발 및 테스트 단계에서는 자원을 모듈별로 구축하여 검증한 뒤 즉각 삭제(Destroy)하고, 최종 검증이 완료되었을 때 전체 시스템을 한 번에 배포(Provisioning)하고 회수(Teardown)하는 **'무결점 폐기(Clean Teardown)' 전략**이 필수적입니다.

이러한 접근법은 단순히 비용을 아끼는 것을 넘어, 코드로 관리되는 인프라(IaC)의 멱등성(Idempotency, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질)을 검증하는 핵심 아키텍처 패턴입니다.

---

### 1. 단계별 구축 및 단위 테스트 (Unit Testing of Infrastructure)

처음부터 모든 코드를 한 번에 실행하면 오류가 발생했을 때 디버깅이 매우 어렵고, 인프라가 롤백되는 과정에서 고아 자원(Orphaned Resource)[^1]이 남아 과금을 유발할 수 있습니다.

* **네트워크 계층 단독 검증:** VPC(Virtual Private Cloud, 가상 프라이빗 클라우드)와 서브넷(Subnet)만 먼저 `terraform apply`로 생성하여 라우팅 테이블과 IP 대역이 맞는지 확인 후 즉시 `terraform destroy`를 실행합니다.
> ⚠️ **AWS 과금 주의:** 이 과정에서 NAT Gateway(네트워크 주소 변환 게이트웨이)가 생성되었다면 테스트가 끝나는 즉시 파괴해야 시간당 과금을 막을 수 있습니다.


* **컴퓨팅/DB 계층 타겟팅 검증:** 네트워크가 검증되면 `terraform apply -target=module.eks`와 같이 특정 타겟만 지정하여 EKS(Elastic Kubernetes Service, 엘라스틱 쿠버네티스 서비스) 클러스터나 RDS(Relational Database Service, 관계형 데이터베이스 서비스)의 생성 여부만 확인하고 폐기합니다.

### 2. 전체 시스템 일괄 구축 (Batch Provisioning)

개별 검증이 완료된 코드는 하나의 파이프라인(또는 쉘 스크립트)을 통해 순차적으로 일괄 구축되어야 합니다. 의존성에 따라 정확한 순서를 지키는 것이 핵심입니다.

1. **Terraform 인프라 구축:** `terraform init` -> `terraform plan` -> `terraform apply -auto-approve`를 통해 AWS 실물 자원을 생성합니다.
2. **Kubeconfig 자격 증명 갱신:** 생성된 EKS 클러스터에 접근하기 위해 터미널의 자격 증명을 갱신합니다.
3. **Kubernetes 리소스 배포:** `kubectl apply -f kubernetes/` 명령어로 쿠버네티스 내부의 Add-on(애드온), 프론트엔드, 백엔드 애플리케이션을 일괄 배포합니다.

### 3. 가장 중요한 '무결점 폐기(Clean Teardown)' 순서

자원을 삭제할 때는 **반드시 구축의 역순**으로 진행해야 합니다. 이 순서를 어기면 인프라 간의 의존성 충돌(Dependency Lock)로 인해 삭제가 실패하고 시스템이 꼬이게 됩니다.

#### ❌ 실패하는 삭제 시나리오 (안티 패턴)

쿠버네티스 자원을 그대로 둔 채 `terraform destroy`를 먼저 실행합니다.

* **결과:** 쿠버네티스의 Ingress(인그레스)가 만들어놓은 AWS ALB(Application Load Balancer, 애플리케이션 로드 밸런서)나, Pod가 동적으로 생성한 EBS(Elastic Block Store, 엘라스틱 블록 스토어) 볼륨은 Terraform의 상태 파일(State File)에 기록되어 있지 않습니다.
* **장애 발생:** Terraform은 VPC를 지우려고 시도하지만, K8s가 만든 ALB가 VPC의 서브넷을 물고 있기 때문에 `DependencyViolation` 에러가 발생하며 삭제가 중단됩니다. 결국 숨어있는 자원으로 인해 지속적인 비용이 발생합니다.

#### ✅ 성공하는 일괄 삭제 시나리오 (Best Practice)

1. **쿠버네티스 자원 선제 삭제:** `kubectl delete -f kubernetes/` 명령을 실행합니다. 이 과정에서 K8s의 AWS Load Balancer Controller가 AWS API를 호출하여 생성했던 ALB와 관련 타겟 그룹(Target Group)을 깨끗하게 정리합니다.
2. **클러스터 내부 자원 정리 대기:** 모든 K8s 서비스와 포드가 완전히 종료(`Terminated`)되었는지 확인합니다.
3. **Terraform 인프라 삭제:** 마지막으로 `terraform destroy -auto-approve`를 실행합니다. 의존성이 모두 해제되었으므로 EKS, RDS, VPC, NAT Gateway 등이 완벽하게 클린업(Clean-up)됩니다.

---

### 💡 실전 팁 및 자주 오해하거나 실수하는 부분

**💡 실전 팁 1: 스크립트(Makefile 또는 Shell Script) 활용**
매번 긴 명령어를 순서대로 치는 것은 휴먼 에러를 유발합니다. [Terraform 공식 문서](https://developer.hashicorp.com/terraform/tutorials)(출처: HashiCorp)에서 권장하는 것처럼 `deploy.sh`와 `destroy.sh`를 만들어 자동화하는 것이 현업의 표준입니다.

```bash
# destroy.sh 예시
echo "1. Kubernetes 리소스 삭제 중..."
kubectl delete -f ./kubernetes/

echo "2. AWS Load Balancer 등 잔여 리소스 해제 대기 (60초)..."
sleep 60

echo "3. Terraform 인프라 일괄 삭제 중..."
cd terraform && terraform destroy -auto-approve

```

**💡 실전 팁 2: RDS 최종 스냅샷 방지**
테라폼으로 RDS를 삭제할 때, 기본 설정은 데이터 유실을 막기 위해 삭제 직전 '최종 스냅샷(Final Snapshot)'을 생성하도록 되어 있습니다. 테스트 환경에서는 이 스냅샷들이 계속 쌓여 **S3 스토리지 비용을 기하급수적으로 발생**시킵니다.

* **해결책:** Terraform RDS 코드 블록에 `skip_final_snapshot = true` 옵션을 반드시 추가해야 테스트용 DB가 과금 없이 완전히 증발합니다.

**💡 자주 오해하는 부분: "삭제 명령을 내렸으니 바로 꺼도 되겠지?"**
`terraform destroy` 명령을 실행했다고 해서 즉각 모든 자원이 사라지는 것은 아닙니다. EKS 클러스터 삭제에 10~15분, RDS 삭제에 5~10분이 소요됩니다. 터미널 창을 미리 닫아버리면 프로세스가 중단되어 클라우드 상에 반쯤 지워진 좀비 자원이 남아 과금을 유발할 수 있습니다. 반드시 `Destroy complete!` 메시지를 눈으로 확인해야 합니다.

---

**[주석]**

* [^1] **고아 자원 (Orphaned Resource):** 상위 관리 도구(Terraform 등)의 추적 상태에서 벗어나 클라우드에 덩그러니 남겨진 자원을 뜻합니다. 관리자도 모르는 사이에 지속적인 비용을 발생시키는 주범이 됩니다.

---

Next Step: 쉘 스크립트(Shell Script) 기반 일괄 배포/삭제 자동화 코드 작성 및 Terraform State(테라폼 상태) 관리 기법

---

(내 개인별 맞춤 설정 확인: 요청하신 대로 모든 시스템을 한 번에 구축하고 한 번에 안전하게 폐기하기 위한 순서와 의존성 문제(특히 K8s와 Terraform 간의 충돌)를 전문가 관점에서 분석하여 교재 양식으로 작성했습니다. 지시하신 대로 과금 주의 사항과 실무 예제를 포함하고 깃허브 마크다운 포맷을 준수했습니다.)
